package org.de013.shoppingcart.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

/**
 * JWT Token Validator
 * Lightweight JWT token validation for Shopping Cart Service
 * Validates tokens generated by User Service
 */
@Component
@Slf4j
public class JwtTokenValidator {

    private final SecretKey secretKey;

    public JwtTokenValidator(
            @Value("${shopping-cart.security.jwt.secret:mySecretKey123456789012345678901234567890}") String secret) {
        this.secretKey = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
    }

    // ==================== TOKEN VALIDATION ====================

    /**
     * Validate JWT token
     */
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                .setSigningKey(secretKey)
                .build()
                .parseClaimsJws(token);
            return true;
        } catch (SecurityException e) {
            log.error("Invalid JWT signature: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            log.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            log.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            log.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            log.error("JWT claims string is empty: {}", e.getMessage());
        }
        return false;
    }

    /**
     * Extract username from JWT token
     */
    public String getUsernameFromToken(String token) {
        try {
            Claims claims = Jwts.parserBuilder()
                .setSigningKey(secretKey)
                .build()
                .parseClaimsJws(token)
                .getBody();
            return claims.getSubject();
        } catch (Exception e) {
            log.error("Error extracting username from token: {}", e.getMessage());
            return null;
        }
    }

    /**
     * Extract user ID from JWT token
     */
    public String getUserIdFromToken(String token) {
        try {
            Claims claims = Jwts.parserBuilder()
                .setSigningKey(secretKey)
                .build()
                .parseClaimsJws(token)
                .getBody();
            return claims.get("userId", String.class);
        } catch (Exception e) {
            log.error("Error extracting user ID from token: {}", e.getMessage());
            return null;
        }
    }

    /**
     * Extract roles from JWT token
     */
    @SuppressWarnings("unchecked")
    public List<String> getRolesFromToken(String token) {
        try {
            Claims claims = Jwts.parserBuilder()
                .setSigningKey(secretKey)
                .build()
                .parseClaimsJws(token)
                .getBody();
            return claims.get("roles", List.class);
        } catch (Exception e) {
            log.error("Error extracting roles from token: {}", e.getMessage());
            return List.of();
        }
    }

    /**
     * Extract session ID from JWT token
     */
    public String getSessionIdFromToken(String token) {
        try {
            Claims claims = Jwts.parserBuilder()
                .setSigningKey(secretKey)
                .build()
                .parseClaimsJws(token)
                .getBody();
            return claims.get("sessionId", String.class);
        } catch (Exception e) {
            log.error("Error extracting session ID from token: {}", e.getMessage());
            return null;
        }
    }

    /**
     * Extract all claims from JWT token
     */
    public Claims getClaimsFromToken(String token) {
        try {
            return Jwts.parserBuilder()
                .setSigningKey(secretKey)
                .build()
                .parseClaimsJws(token)
                .getBody();
        } catch (Exception e) {
            log.error("Error extracting claims from token: {}", e.getMessage());
            return null;
        }
    }

    // ==================== GUEST TOKEN GENERATION (Minimal) ====================

    /**
     * Generate simple guest token for anonymous cart access
     * Note: User tokens should be generated by User Service
     */
    public String generateGuestToken(String sessionId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + (2 * 60 * 60 * 1000)); // 2 hours for guests

        return Jwts.builder()
            .setSubject("guest")
            .claim("userId", null)
            .claim("roles", List.of("GUEST"))
            .claim("sessionId", sessionId)
            .claim("isGuest", true)
            .setIssuer("shopping-cart-service")
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(secretKey, SignatureAlgorithm.HS512)
            .compact();
    }

    // ==================== AUTHENTICATION CREATION ====================

    /**
     * Create Authentication object from JWT token
     */
    public Authentication getAuthentication(String token) {
        try {
            Claims claims = getClaimsFromToken(token);
            if (claims == null) {
                return null;
            }

            String username = claims.getSubject();
            String userId = claims.get("userId", String.class);
            @SuppressWarnings("unchecked")
            List<String> roles = claims.get("roles", List.class);
            String sessionId = claims.get("sessionId", String.class);
            Boolean isGuest = claims.get("isGuest", Boolean.class);

            Collection<GrantedAuthority> authorities = roles.stream()
                .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
                .collect(Collectors.toList());

            UserDetails userDetails = User.builder()
                .username(username)
                .password("") // No password needed for JWT
                .authorities(authorities)
                .build();

            return new JwtAuthenticationToken(userDetails, token, authorities, userId, sessionId, Boolean.TRUE.equals(isGuest));

        } catch (Exception e) {
            log.error("Error creating authentication from token: {}", e.getMessage());
            return null;
        }
    }

    // ==================== TOKEN UTILITY METHODS ====================

    /**
     * Check if token is expired
     */
    public boolean isTokenExpired(String token) {
        try {
            Claims claims = getClaimsFromToken(token);
            return claims != null && claims.getExpiration().before(new Date());
        } catch (Exception e) {
            return true;
        }
    }

    /**
     * Get token expiration date
     */
    public Date getExpirationDateFromToken(String token) {
        try {
            Claims claims = getClaimsFromToken(token);
            return claims != null ? claims.getExpiration() : null;
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Check if user has specific role
     */
    public boolean hasRole(String token, String role) {
        try {
            List<String> roles = getRolesFromToken(token);
            return roles.contains(role);
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Check if token is for guest user
     */
    public boolean isGuestToken(String token) {
        try {
            Claims claims = getClaimsFromToken(token);
            return claims != null && Boolean.TRUE.equals(claims.get("isGuest", Boolean.class));
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Refresh guest token only (user tokens should be refreshed by User Service)
     */
    public String refreshGuestToken(String token) {
        try {
            Claims claims = getClaimsFromToken(token);
            if (claims == null) {
                return null;
            }

            Boolean isGuest = claims.get("isGuest", Boolean.class);
            if (!Boolean.TRUE.equals(isGuest)) {
                log.warn("Attempted to refresh non-guest token in Shopping Cart Service");
                return null;
            }

            String sessionId = claims.get("sessionId", String.class);
            return generateGuestToken(sessionId);

        } catch (Exception e) {
            log.error("Error refreshing guest token: {}", e.getMessage());
            return null;
        }
    }

    /**
     * Extract token from Authorization header
     */
    public String extractTokenFromHeader(String authHeader) {
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            return authHeader.substring(7);
        }
        return null;
    }

    /**
     * Validate token format
     */
    public boolean isValidTokenFormat(String token) {
        return token != null && token.split("\\.").length == 3;
    }
}
